\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{graphicx}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=red,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Report\\Namcap}

\author{Team 2, VPB Game Studio
		\\ Prajvin Jalan (jalanp)
		\\ Vatsal Shukla (shuklv2)
		\\ Baltej Toor (toorbs)
}

\date{\today}

\input{../Comments}

\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[h]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2016-12-08 & 1.0 & Completion of Functional Requirements Evaluation\\
2016-12-08 & 1.1 & Completion of Unit Testing Section\\
2016-12-08 & 1.2 & Completion of Changes Due to Testing\\
2016-12-08 & 1.3 & Completion of Automated Testing\\
2016-12-08 & 1.4 & Addition of Traceability Matrices and explanation of code coverage metrics\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\pagenumbering{arabic}

This document ...

\section{Functional Requirements Evaluation}

\subsection{Game Functionality Testing}

\paragraph{}
A Robot (automated) unit testing class was implemented and used to test the mechanics of the game.

\subparagraph{General Testing}

\begin{enumerate}

\item{\label{gft1}{GFT1}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Application is displaying the main menu page
					
Input: Cursor clicked on Start Game button
					
Expected Output: New game is started and window is changed to reflect a new game state

Output: New game was started and window was changed to reflect a new game state

Result: PASS

\setcounter{enumi}{10}
\item{\label{gft11}{GFT11}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Within game state
					
Input: Escape button pressed
					
Expected Output: Application must pause and ask user if they want to quit

Output: Game was paused and user was asked to quit or continue

Result: PASS

\end{enumerate}

\subparagraph{Player Movement/Collision Testing}

\begin{enumerate}
\setcounter{enumi}{1}
\item{\label{gft2}{GFT2}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Within the game state
					
Input: Arrow keys
					
Expected Output: Player moves in the respective direction (if path is clear)

Output: Player moved in the respective direction when path was clear
					
Result: PASS

\item{\label{gft3}{GFT3}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player comes in contact with wall
					
Input: No input
					
Expected Output: Player stops moving when coming in contact with the wall

Output: Player's x and y coordinates were not changed when in contact with the wall

Result: PASS

\item{\label{gft4}{GFT4}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player comes in contact with enemy
					
Input: No input
					
Expected Output: If player has more than 1 life, decrement lives. If player has one life, end game.

Output: Player's life was decremented by 1 when player had more than one life. The game was ended if player was on their last life.

Result: PASS
\setcounter{enumi}{5}
\item{\label{gft6}{GFT6}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player comes in contact with dots
					
Input: Arrow keys
					
Expected Output: Dot disappears after collection

Output: Dot disappeared afer player colletcted it

Result: PASS

\item{\label{gft7}{GFT7}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collects the big dot
					
Input: Arrow keys
					
Expected Output: Big dot disappears after collection

Output: Big dot disappeared after player collected it

Result: PASS

\item{\label{gft8}{GFT8}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collects the big dot
					
Input: Arrow keys
					
Expected Output: Player is able to collide with enemies

Output: Player does not lose any lives when colliding with enemy

Result: PASS

\end{enumerate}

\subparagraph{Enemy Movement/Collision Testing}

\begin{enumerate}
\setcounter{enumi}{4}
\item{\label{gft5}{GFT5}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Within the game state
					
Input: No input
					
Expected Output: Enemies move on a valid path

Output: Enemy does not go through barriers

Result: PASS
\setcounter{enumi}{8}
\item{\label{gft9}{GFT9}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collects the big dot
					
Input: No input
					
Expected Output: Enemies change colour

Output: Enemies changed colours

Result: PASS
\setcounter{enumi}{13}
\item{\label{gft14}{GFT14}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collides with enemy after collection of big dot
					
Input: Arrow keys
					
Expected Output: Enemy is removed from game and respawned back to their original cell

Output: Enemy is respawned back to the center of the game

Result: PASS

\end{enumerate}

\subparagraph{Scoring Testing}

\begin{enumerate}
\setcounter{enumi}{9}
\item{\label{gft10}{GFT10}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collects all dots
					
Input: Arrow keys
					
Expected Output: Game over screen is activated

Output: Player's score is displayed along with the Game Over screen

Result: PASS
\setcounter{enumi}{11}
\item{\label{gft12}{GFT12}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collects dot
					
Input: Arrow keys
					
Expected Output: The points are increased

Output: Player's score is increased by 100

Result: PASS

\item{\label{gft13}{GFT13}\\}

Type: Functional, Dynamic, Automated
					
Initial State: Player collects big dot
					
Input: Arrow keys
					
Expected Output: The points are increased at twice the rate

Output: Player's score is increased by 200

Result: PASS

\end{enumerate}

\section{Nonfunctional Requirements Evaluation}

\subsection{Usability}
		
\subsection{Performance}

\subsection{etc.}
	
\section{Comparison to Existing Implementation}	

This section will not be appropriate for every project.

\section{Unit Testing}

Unit Testing for Namcap was done using Java's JUnit testing suite, and results of all tests were written and summarized to a text file. If any tests failed, the exception would be included so the development team could analyze and repair any errors. Figure \ref{FigUTR} is an example of the text file.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{UnitTestResults.png}
\caption{Unit Test Results}
\label{FigUTR}
\end{figure}

{\bf Test Cases}

\begin{enumerate}

\item{\label{ut1}{UT1}\\}

Type: Unit, Static, Automated
					
Initial State: Application is displaying the main menu page
					
Input: Start Game button action is performed
					
Expected Output: New game is started and window is changed to reflect a new game state
					
Output: New window (game board) successfully opened

JUnit Test Result: PASS

\item{\label{ut2}{UT2}\\}

Type: Unit, Static, Automated
					
Initial State: Player is in starting position at the start of the game
					
Input: Current X accessor method for the player
					
Expected Output: 200 (start X position)
					
Output: 200

JUnit Test Result: PASS

\item{\label{ut3}{UT3}\\}

Type: Unit, Static, Automated
					
Initial State: Player is in starting position at the start of the game
					
Input: Current Y accessor method for the player
					
Expected Output: 300 (start Y position)
					
Output: 300

JUnit Test Result: PASS

\item{\label{ut4}{UT4}\\}

Type: Unit, Static, Automated
					
Initial State: Player is in starting position at the start of the game
					
Input: Current direction of the player
					
Expected Output: 'R' (player starting direction)
					
Output: 'R'

JUnit Test Result: PASS

\item{\label{ut5}{UT5}\\}

Type: Unit, Static, Automated
					
Initial State: Player is in starting position at the start of the game
					
Input: PlayerX, PlayerY, EnemyX, EnemyY (200,300,185,300)
					
Expected Output: Player lives decremented (player to enemy collision succeeded)
					
Output: 2 (player lives left)

JUnit Test Result: PASS

\item{\label{ut6}{UT6}\\}

Type: Unit, Static, Automated
					
Initial State: Player is in starting position at the start of the game, all dots are on map
					
Input: PlayerX, PlayerY ([180,300],[20,180],[20,180])
					
Expected Output: Score increases the first two times, but not the last
					
Output: ([score increases to 100, no dot],[score increases to 200, no dot],[score remains at 200, no dot])

Junit Test Result: PASS

\item{\label{ut7}{UT7}\\}

Type: Unit, Static, Automated
					
Initial State: Player is in starting position at the start of the game
					
Input: X and Y positions around the player (Player Positions tested (X,Y): [200,300],[20,20],[100,180])
					
Expected Output: 2 barriers around the first position, 2 barriers around the second position, 0 barriers around the third position - true and false values
					
Output: ([false,false,true,true],[true,false,true,false],[false,false,false,false])

Junit Test Result: PASS

\item{\label{ut8}{UT8}\\}

Type: Unit, Static, Automated
					
Initial State: Board is created with only barrier and dot entities
					
Input: X and Y positions for all barrier locations
					
Expected Output: True for all barrier locations (manually stated in JUnit class)
					
Output: True for all barrier locations

JUnit Test Result: PASS

\item{\label{ut9}{UT9}\\}

Type: Unit, Static, Automated
					
Initial State: Board is created with only barrier and dot entities
					
Input: X and Y positions for a location without a barrier, and an update to that location (to create a barrier) [10,15]
					
Expected Output: True, a barrier exists for that location [10,15]
					
Output: True

JUnit Test Result: PASS

\item{\label{ut10}{UT10}\\}

Type: Unit, Static, Automated
					
Initial State: Board is created with only barrier and dot entities
					
Input: X and Y positions for dot locations
					
Expected Output: True for all dot locations (manually stated in JUnit class)
					
Output: True for all dot locations (true that they are all 1)

JUnit Test Result: PASS

\item{\label{ut11}{UT11}\\}

Type: Unit, Static, Automated
					
Initial State: Board is created with only barrier and dot entities
					
Input: X and Y positions for a location without a dot, and an update to that location (to create a dot) [0,0]
					
Expected Output: True, a dot exists for that location [0,0]
					
Output: True

JUnit Test Result: PASS

\item{\label{ut12}{UT12}\\}

Type: Unit, Static, Automated
					
Initial State: Board is created with game entities, player and score objects are created
					
Input: Score values to increase by ([1000],[1313232],[0])
					
Expected Output: Updated score value after each addition ([1000],[1314232],[1314232])
					
Output: Score updated successfully ([1000],[1314232],[1314232])

JUnit Test Result: PASS

\item{\label{utf1}{UTF1}\\}

Type: Unit, Dynamic, Automated
					
Initial State: Application is in gameplay state
					
Input: Score addition (16000); High score update; Score addition (4000); High score read from file
					
Expected Output: High score not affected by score addition within game (should be read as 16000)
					
Output: High score remains as updated (16000)

JUnit Test Result: PASS

\end{enumerate}

\section{Changes Due to Testing}

There were virtually no changes we made to the actual functionality of the game based on the testing. All of the performed tests were passed with no issues. On the other hand, based on the feedback we received from the usability survey, 30\% of the users stated that the game looked too similar to the original Pacman game. Thus, we decided to change the colour of the map from Blue to Red, we switched the roles of the Ghost and the Pacman and added a little backstory to reflect that change and to add a unique persepctive to Namcap. Other than the mentioned changes, we did not see any reason to change anything else since it was functioning perfectly well.


\section{Automated Testing}

As discussed in the test plan, the automated testing was used to test the Functional Requirements and the Unit Tests. For the functional requirements/scenarios, a java Robot class was used to simulate button presses and key presses to verify that the requirements are met. For example, the Robot class was used to simulate the pressing of the arrow keys in order to test if the player moves in the correct direction. The JUnit testing framework was used to validate that every game mechanic (scoring, barriers, player/enemy positions, etc.) is working as required.
		
\section{Trace to Requirements}
This section shows the traceability matrix between test cases and requirements. Non-functional requirements are not referenced as they pertain to primarily, application-wide qualities and are trace-able to all tests. Non-functional test cases are excluded as they will cover all requirements as application-wide qualities.

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Req.} & \textbf{Tests}\\
\midrule
\href{../SRS/SRS.pdf#f1}{F1} & GFT\ref{gft1}, UT\ref{ut1}. UT\ref{ut2}, UT\ref{ut3}, UT\ref{ut4}, UT\ref{ut10}, UT\ref{ut11}, UT\ref{ut12}\\
\href{../SRS/SRS.pdf#f2}{F2} & GFT\ref{gft2}\\
\href{../SRS/SRS.pdf#f3}{F3} & GFT\ref{gft3}, UT\ref{ut7}, UT\ref{ut8}, UT\ref{ut9}\\
\href{../SRS/SRS.pdf#f4}{F4} & GFT\ref{gft4}, UT\ref{ut5}\\
\href{../SRS/SRS.pdf#f5}{F5} & GFT\ref{gft5}\\
\href{../SRS/SRS.pdf#f6}{F6} & GFT\ref{gft5}\\
\href{../SRS/SRS.pdf#f7}{F7} & GFT\ref{gft6}, GFT\ref{gft10}, GFT\ref{gft12}, UT\ref{ut6}, UT\ref{ut8}, UT\ref{ut10}, UT\ref{ut11}\\
\href{../SRS/SRS.pdf#f8}{F8} & GFT\ref{gft7}, GFT\ref{gft9}, GFT\ref{gft13}, GFT\ref{gft14}, UT\ref{ut6}, UT\ref{ut8}, UT\ref{ut10}, UT\ref{ut11}\\
\href{../SRS/SRS.pdf#f9}{F9} & GFT\ref{gft8}, GFT\ref{gft13}, GFT\ref{gft14}\\
\href{../SRS/SRS.pdf#f10}{F10} & GFT\ref{gft9}\\
\href{../SRS/SRS.pdf#f11}{F11} & GFT\ref{gft10}\\
\href{../SRS/SRS.pdf#f12}{F12} & GFT\ref{gft11}\\
\href{../SRS/SRS.pdf#f13}{F13} & GFT\ref{gft12}, UT\ref{ut12}, UTF\ref{utf1}\\
\href{../SRS/SRS.pdf#f14}{F14} & GFT\ref{gft13}, UT\ref{ut12}, UTF\ref{utf1}\\
\href{../SRS/SRS.pdf#f15}{F15} & GFT\ref{gft14}\\
%\href{../SRS/SRS.pdf#nf1}{NF1} & \\
%\href{../SRS/SRS.pdf#nf2}{NF2} & \\
%\href{../SRS/SRS.pdf#nf3}{NF3} & \\
%\href{../SRS/SRS.pdf#nf4}{NF4} & \\
%\href{../SRS/SRS.pdf#nf5}{NF5} & \\
%\href{../SRS/SRS.pdf#nf6}{NF6} & \\
%\href{../SRS/SRS.pdf#nf7}{NF7} & \\
\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Tests}
\label{TblRT}
\end{table}
		
\section{Trace to Modules}
This section shows the traceability matrix between test cases and modules. Non-functional test cases are excluded as they will cover all modules as application-wide qualities.		

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Mod.} & \textbf{Tests}\\
\midrule
\href{../Design/MG/MG.pdf#m1}{M1} & GFT\ref{gft1}, UT\ref{ut1}\\
\href{../Design/MG/MG.pdf#m2}{M2} & GFT\ref{gft2}, GFT\ref{gft3}, GFT\ref{gft4},  UT\ref{ut2},  UT\ref{ut3},  UT\ref{ut4},  UT\ref{ut5}\\
\href{../Design/MG/MG.pdf#m3}{M3} & GFT\ref{gft2}, GFT\ref{gft3}, GFT\ref{gft4}, GFT\ref{gft6}, GFT\ref{gft7}, GFT\ref{gft8}, GFT\ref{gft12}, GFT\ref{gft13}, GFT\ref{gft14}, UT\ref{ut2}, UT\ref{ut3}, UT\ref{ut4}, UT\ref{ut5}, UT\ref{ut6}, UT\ref{ut7}, UT\ref{ut8}, UT\ref{ut9}, UT\ref{ut12}\\
\href{../Design/MG/MG.pdf#m4}{M4} & GFT\ref{gft2}, GFT\ref{gft3}, GFT\ref{gft4}, GFT\ref{gft5}, GFT\ref{gft6}, GFT\ref{gft7}, GFT\ref{gft8}, GFT\ref{gft10}, GFT\ref{gft11}, GFT\ref{gft12}, GFT\ref{gft13}, GFT\ref{gft14}, UT\ref{ut2}, UT\ref{ut3}, UT\ref{ut4}, UT\ref{ut5}, UT\ref{ut7}, UT\ref{ut8}, UT\ref{ut9}, UT\ref{ut10}, UT\ref{ut11}, UT\ref{ut12}\\
\href{../Design/MG/MG.pdf#m5}{M5} & GFT\ref{gft12}, GFT\ref{gft13}, GFT\ref{gft14}, UT\ref{ut6}, UT\ref{ut12}, UTF\ref{utf1},\\
\href{../Design/MG/MG.pdf#m6}{M6} & GFT\ref{gft1}\\
\href{../Design/MG/MG.pdf#m7}{M7} & GFT\ref{gft2}, GFT\ref{gft3}, GFT\ref{gft4}, GFT\ref{gft5}, GFT\ref{gft6}, GFT\ref{gft7}, GFT\ref{gft8}, GFT\ref{gft9}, GFT\ref{gft10}, GFT\ref{gft11}, GFT\ref{gft12}, GFT\ref{gft13}, GFT\ref{gft14}, UT\ref{ut12}\\
\href{../Design/MG/MG.pdf#m8}{M8} & GFT\ref{gft11}, UT\ref{ut12}\\
\href{../Design/MG/MG.pdf#m9}{M9} & GFT\ref{gft2}, UT\ref{ut4}, UT\ref{ut12}\\
\href{../Design/MG/MG.pdf#m10}{M10} & GFT\ref{gft4}, GFT\ref{gft5}, GFT\ref{gft8}, GFT\ref{gft9}, GFT\ref{gft14}, UT\ref{ut5}, UT\ref{ut12}\\
\bottomrule
\end{tabular}
\caption{Trace Between Modules and Tests}
\label{TblMT}
\end{table}

\section{Code Coverage Metrics}
JaCoCo is the planned code coverage tool to be utilized to act as a metric for code coverage of the implementation. By default, a JaCoCo agent can be attached to a JVM on start. Whenever a class is loaded JaCoCo instruments the class in order to see when it is called and which lines are executed. It then uses this information to build the coverage statistics which creates a results file when the JVM terminates. Based on time constraints for this development, the code coverage metrics tasks have been moved to future development.

%\bibliographystyle{plainnat}

%\bibliography{SRS}

\end{document}